import base64
import binascii
import datetime
import hashlib
import hmac
from urllib.parse import parse_qs, urlparse

import requests

from .exceptions import InvalidParametersException, PayboxEndpointException
from Crypto.Hash import SHA
from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_v1_5
from django.conf import settings


class PayboxSystemTransaction:
    """A Paybox System transaction, from your server to the customer's browser, and from Paybox server to yours
    Attributes:
        REQUIRED   The values nedded to call for a payment
        OPTIONAL   The values you may add to modify Paybox behavior
        RESPONSE_CODES  Every response code Paybox may return after a payment attempt
    """

    def __init__(
            self,
            production=False,
            total=None,
            cmd=None,
            porteur=None,
            time=None,
            repondre_a=None,
            refuse=None,
            effectue=None,
            annule=None,
            attente=None,
            langue=None,
            hash=None,
            devise=None,
            subscription=False,
            subscription_amount=None,
            nbpaie=None,
            freq=None,
            quand=None,
            delais=None,
            several_payments=False,
            mont1=None,
            date1=None,
            mont2=None,
            date2=None,
            mont3=None,
            date3=None,
            authorize_without_capture=False,
            diff=None,
            paybox_system_standard=False,
            paybox_system_light=False,
            paybox_system_mobile=False,
            secure_3d=False,
            card_verification_browser_redirect_url=None
    ):
        self.production = production
        self.subscription = subscription
        self.several_payments = several_payments
        self.authorize_without_capture = authorize_without_capture
        self.paybox_system_standard = paybox_system_standard,
        self.paybox_system_light = paybox_system_light,
        self.paybox_system_mobile = paybox_system_mobile
        self.secure_3d = secure_3d
        self.card_verification_api_redirect_url = card_verification_browser_redirect_url

        if self.production:
            self.action_url = "https://tpeweb.e-transactions.fr/php/"
            self.KEY = settings.PAYBOX_PUBLIC_KEY
        else:
            self.action_url = "https://preprod-tpeweb.e-transactions.fr/php/"
            self.KEY = settings.PAYBOX_TEST_PUBLIC_KEY

        self.SUPPORTED_HASH_ALGORITHMS = [
            "SHA512",
            "SHA224",
            "SHA256",
            "SHA384"
        ]

        self.REQUIRED = {
            "PBX_SITE": settings.PAYBOX_SITE,  # SITE NUMBER (given by Paybox)
            "PBX_RANG": settings.PAYBOX_RANG,  # RANG NUMBER (given by Paybox)
            "PBX_IDENTIFIANT": settings.PAYBOX_IDENTIFIANT,  # IDENTIFIANT NUMBER (given by Paybox)
            "PBX_TOTAL": total,  # Total amount of the transaction, in cents
            "PBX_DEVISE": devise if devise else "978",  # Currency of the transaction
            "PBX_CMD": cmd,  # Transaction reference generated by the ecommerce
            "PBX_PORTEUR": porteur,  # Customer's email address
            "PBX_RETOUR": "TO:M;RE:R;AU:A;RC:E;SIGN:K",  # List of the variables Paybox must return to the IPN url
            "PBX_HASH": hash if hash and hash in self.SUPPORTED_HASH_ALGORITHMS else "SHA512",  # Hash algorithm used to calculate the Hmac value
            "PBX_TIME": time if time else datetime.datetime.utcnow().isoformat(),  # Time of the transaction (iso 8601 format)
        }

        self.OPTIONAL = {
            "PBX_REFUSE": refuse,  # url de retour en cas de refus de paiement
            "PBX_REPONDRE_A": repondre_a,  # url IPN. WARNING. With Trailing slash, otherwise Django 301 to it...
            "PBX_EFFECTUE": effectue,  # url de retour en cas de succes
            "PBX_ANNULE": annule,  # url de retour en cas d'abandon
            "PBX_ATTENTE": attente,  # url de retour en cas d'abandon
            "PBX_LANGUE": langue if langue else "GBR",  # 3 Chars. payment language. GBR for English
            "PBX_DIFF": diff
        }

        self.SUBSCRIPTION = {
            "PBX_2MONT": subscription_amount,  # Amount of the next term of payment in cents. 0 takes amount in PBX_TOTAL
            "PBX_NBPAIE": nbpaie,  # Number of subsequent subscription payments. 0 is never ending
            "PBX_FREQ": freq,  # Frequency of payments in months
            "PBX_QUAND": quand,  # Day of month for for the payment to be executed
            "PBX_DELAIS": delais,  # Number of days to delay before fist payment is executed
        }

        self.SEVERAL_PAYMENTS = {
            "PBX_2MONT1": mont1,
            "PBX_DATE1": date1,
            "PBX_2MONT2": mont2,
            "PBX_DATE2": date2,
            "PBX_2MONT3": mont3,
            "PBX_DATE3": date3
        }

        self.RESPONSE_CODES = {
            "00000": "Success",
            "00001": "Connection failed. Make a new attempt at tpeweb1.paybox.com",
            "001xx": "Payment rejected",
            "00003": "Paybox error. Make a new attempt at tpeweb1.paybox.com",
            "00004": "Card number invalid",
            "00006": "site, rang, or identifiant invalid. Connection rejected",
            "00008": "Card expiration date invalid",
            "00009": "Error while creating a subscription",
            "00010": "Unrecognized currency",
            "00011": "Incorrect amount",
            "00015": "Payment already done",
            "00016": "Subscriber already known",
            "00021": "Unauthorized card",
            "00029": "Incorrect card number",
            "00030": "Time out",
            "00031": "Reserved",
            "00032": "Reserved",
            "00033": "Country not supported",
            "00040": "3DSecure validation failed",
            "99999": "Payment on hold",
        }

        self.PAYBOX_SYSTEM_MODES = [
            "paybox_system_standard",
            "paybox_system_light",
            "paybox_system_mobile"
        ]

    def payment_mode(self):
        try:
            if settings.PAYBOX_SYSTEM_MODE:
                if settings.PAYBOX_SYSTEM_MODE in self.PAYBOX_SYSTEM_MODES:
                    return settings.PAYBOX_SYSTEM_MODE
            else:
                if self.paybox_system_mobile:
                    return "paybox_system_mobile"
                elif self.paybox_system_light:
                    return "paybox_system_light"
                else:
                    return "paybox_system_standard"
        except AttributeError:
            return "paybox_system_standard"

    def endpoint_url(self):
        payment_mode = self.payment_mode()
        if payment_mode == "paybox_system_mobile":
            if self.production:
                main_url = "https://tpeweb.paybox.com/cgi/ChoixPaiementMobile.cgi"
                backup_url = "https://tpeweb1.paybox.com/cgi/ChoixPaiementMobile.cgi"
                request = requests.get(main_url)
                if request.status_code == 200:
                    return main_url
                else:
                    request = requests.get(backup_url)
                    if request.status_code == 200:
                        return backup_url
            else:
                return "https://preprod-tpeweb.paybox.com/cgi/ChoixPaiementMobile.cgi"
        elif payment_mode == "paybox_system_light":
            if self.production:
                main_url = "https://tpeweb.paybox.com/cgi/MYframepagepaiement_ip.cgi"
                backup_url = "https://tpeweb1.paybox.com/cgi/MYframepagepaiement_ip.cgi"
                request = requests.get(main_url)
                if request.status_code == 200:
                    return main_url
                else:
                    request = requests.get(backup_url)
                    if request.status_code == 200:
                        return backup_url
            else:
                return "https://preprod-tpeweb.paybox.com/cgi/MYframepagepaiement_ip.cgi"
        else:
            if self.production:
                main_url = "https://tpeweb.paybox.com/cgi/MYchoix_pagepaiement.cgi"
                backup_url = "https://tpeweb1.paybox.com/cgi/MYchoix_pagepaiement.cgi"
                request = requests.get(main_url)
                if request.status_code == 200:
                    return main_url
                else:
                    request = requests.get(backup_url)
                    if request.status_code == 200:
                        return backup_url
            else:
                return "https://preprod-tpeweb.paybox.com/cgi/MYchoix_pagepaiement.cgi"

    def remote_mpi_url(self):
        if self.production:
            mpi_url1 = "https://tpeweb.paybox.com/cgi/RemoteMPI.cgi"
            mpi_url2 = "https://tpeweb1.paybox.com/cgi/RemoteMPI.cgi"
            mpi_url3 = "https://tpeweb1.paybox.com/cgi/RemoteMPI.cgi"
            mpi_url4 = "https://tpeweb0.paybox.com/cgi/RemoteMPI.cgi"
            request = requests.get(mpi_url1)
            if request.status_code == 200:
                return mpi_url1
            else:
                request = requests.get(mpi_url2)
                if request.status_code == 200:
                    return mpi_url2
                else:
                    request = requests.get(mpi_url3)
                    if request.status_code == 200:
                        return mpi_url3
                    else:
                        request = requests.get(mpi_url4)
                        if request.status_code == 200:
                            return mpi_url4
        else:
            remote_mpi_url = "https://preprod-tpeweb.paybox.com/cgi/RemoteMPI.cgi"
            return remote_mpi_url
        raise PayboxEndpointException(message="Paybox MPI URL is not responsive.")

    def remote_mpi_authenticate(self, session_id):
        """
        To carry out a 3D-Secure transaction, merchants will need to authenticate the cardholder before
        calling Paybox Direct Applications
        :return: {"ID3D": "", "StatusPBX": "", "Check": "", "IdSession": "", "3DCAVV": "",
                 "3DCAVVALGO": "", "3DECI": "", "3DENROLLED": "", "3DERROR": "", "3DSIGNVAL": "",
                 "3DSTATUS": "", "3DXID": "", "Check": ""}
        """
        card_verification_params = {
            "IdSession": session_id,
            "IdMerchant": settings.PAYBOX_IDENTIFIANT,
            "URLRetour": self.card_verification_api_redirect_url,
            "Amount": self.REQUIRED['MONTANT'],
            "Currency": self.REQUIRED['DEVISE'],
            "CCExpDate": self.REQUIRED['DATEVAL'],
            "CCNumber": self.REQUIRED['PORTEUR'],
            "CVVCode": self.OPTIONAL['CVV']
        }
        remote_mpi_call = requests.post(self.remote_mpi_url(), data=card_verification_params)
        return remote_mpi_call.text

    def post_to_paybox(self):
        """
        Returns the Paybox action url, required request variables, and the
        optional variables
        :return: {
                    "action": self.action_url,
                    "required": self.required,
                    "optional": self.optional,
                }
        """
        if self.secure_3d:
            if self.id3d is None:
                raise InvalidParametersException(message="3D Secure payments require mpi authentication.")
        if self.REQUIRED["PBX_HASH"] not in self.SUPPORTED_HASH_ALGORITHMS:
            raise InvalidParametersException(message="Unsupported hash algorithm provided.")
        self.REQUIRED["PBX_DEVISE"] = self.REQUIRED.get("devise", "978")
        if self.authorize_without_capture:
            self.OPTIONAL["PBX_AUTOSEULE"] = 'O'
        # string to sign. Made of the required variables in a precise order.
        tosign = (
                "PBX_SITE=%(PBX_SITE)s&PBX_RANG=%(PBX_RANG)s&PBX_IDENTIFIANT=%(PBX_IDENTIFIANT)s&PBX_TOTAL=%(PBX_TOTAL)s&PBX_DEVISE=%(PBX_DEVISE)s&PBX_CMD=%(PBX_CMD)s&PBX_PORTEUR=%(PBX_PORTEUR)s&PBX_RETOUR=%(PBX_RETOUR)s&PBX_HASH=%(PBX_HASH)s&PBX_TIME=%(PBX_TIME)s"
                % self.REQUIRED
        )
        # Subscription variables
        if self.subscription:
            for key, value in self.SUBSCRIPTION.items():
                if value:
                    tosign += "&" + key + "=" + value
        # Several payments
        if self.several_payments:
            for key, value in self.SEVERAL_PAYMENTS.items():
                if value:
                    tosign += "&" + key + "=" + value
        # Optional variables
        for key, value in self.OPTIONAL.items():
            if value:
                tosign += "&" + key + "=" + value

        binary_key = binascii.unhexlify(self.KEY)
        algorithms = {
            "SHA512": hashlib.sha512,
            "SHA224": hashlib.sha224,
            "SHA256": hashlib.sha256,
            "SHA384": hashlib.sha384
        }
        chosen_algorithm = algorithms.get(self.REQUIRED['PBX_HASH'])
        signature = (
            hmac.new(binary_key, tosign.encode("ascii"), chosen_algorithm)
                .hexdigest()
                .upper()
        )
        self.REQUIRED["hmac"] = signature

        return {
            "action": self.endpoint_url(),
            "required": self.REQUIRED,
            "optional": self.OPTIONAL,
        }

    def construct_html_form(self):
        """ Returns an html form ready to be used (string)
        """
        subscription_fields = "\n".join(
            [
                "<input type='hidden' name='{0}' value='{1}'>".format(
                    field, self.SUBSCRIPTION[field]
                )
                for field in self.SUBSCRIPTION
                if self.SUBSCRIPTION[field]
            ]
        )

        optional_fields = "\n".join(
            [
                "<input type='hidden' name='{0}' value='{1}'>".format(
                    field, self.OPTIONAL[field]
                )
                for field in self.OPTIONAL
                if self.OPTIONAL[field]
            ]
        )

        html = """<form method=POST action="{action}">
            <input type="hidden" name="PBX_SITE" value="{required[PBX_SITE]}">
            <input type="hidden" name="PBX_RANG" value="{required[PBX_RANG]}">
            <input type="hidden" name="PBX_IDENTIFIANT" value="{required[PBX_IDENTIFIANT]}">
            <input type="hidden" name="PBX_TOTAL" value="{required[PBX_TOTAL]}">
            <input type="hidden" name="PBX_DEVISE" value="{required[PBX_DEVISE]}">
            <input type="hidden" name="PBX_CMD" value="{required[PBX_CMD]}">
            <input type="hidden" name="PBX_PORTEUR" value="{required[PBX_PORTEUR]}">
            <input type="hidden" name="PBX_RETOUR" value="{required[PBX_RETOUR]}">
            <input type="hidden" name="PBX_HASH" value="{required[PBX_HASH]}">
            <input type="hidden" name="PBX_TIME" value="{required[PBX_TIME]}">
            <input type="hidden" name="PBX_HMAC" value="{required[hmac]}">
            {subscription}
            {optional}
            <input type="submit" value="Pay">
        </form>"""

        return html.format(
            action=self.endpoint_url(), required=self.REQUIRED, optional=optional_fields,
            subscription=subscription_fields
        )

    def verify_ipn(self, response_url, total, verify_certificate=True):
        """ Verifies the notification sent by Paybox to your server.
        It verifies :
            - the authenticity of the message
            - the fact that the message has not been altered
            - if not in production, the auth_number must be "XXXXXX"
            - if in production, there must be a Response Code
            - the total returned must be equal to the total of the order you've saved in ddb
        :response_url: (string), the full response url with its encoded args
        :order_total': (int), the total amount required
        :verify_certificate: (bool)
        It returns a dict which contains three variables:
            - success, (bool) True if the payment is valid
            - status, (str) The Paybox Response Code
            - auth_code, (str) The Authorization Code generated by the Authorization Center
        """

        url_parsed = urlparse(response_url)
        message = url_parsed.query
        query = parse_qs(message)

        if verify_certificate:
            self.verify_certificate(message=message, signature=query["SIGN"][0])

        if not self.production:
            assert query["AU"][0] == "XXXXXX", "Incorrect Test Authorization Code"
        else:
            assert "RC" in query, "No Response Code Returned"

        assert query["TO"][0] == str(
            total
        ), "Total does not match. PBX: %s - CMD: %s" % (
            query["TO"][0],
            str(total),
        )

        return {
            "success": True if query["RC"][0] == "00000" else False,
            "status": self.RESPONSE_CODES.get(
                query["RC"][0][:-2] + "xx",
                self.RESPONSE_CODES.get(query["RC"][0], "Unrecognized Response Code"),
            ),
            "auth_code": query["AU"][0] if "AU" in query else False,
        }

    def verify_certificate(self, message, signature):
        """ Verifies the Paybox certificate, authenticity and alteration.
        If everything goes well, returns True. Otherwise raise an Error
        :message: (str), the full url with its args
        :signature: (str), the signature of the message, separated from the url
        Flow:
            - The signature is decoded base64
            - The signature is removed from the message
            - The Paybox pubkey is loaded from an external file
            - it's validity is checked
            - The message is digested by SHA1
            - The SHA1 message is verified against the binary signature
        """

        # detach the signature from the message
        message_without_sign = message.split("&SIGN=")[0]
        # decode base64 the signature
        binary_signature = base64.b64decode(signature)
        # create a pubkey object
        if self.production:
            key = RSA.importKey(
                settings.PAYBOX_PUBLIC_KEY
            )
        else:
            key = RSA.importKey(
                settings.PAYBOX_TEST_PUBLIC_KEY if settings.PAYBOX_TEST_PUBLIC_KEY else "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF"
            )
        # digest the message
        h = SHA.new(bytes(message_without_sign, encoding="utf8"))
        # and verify the signature
        verifier = PKCS1_v1_5.new(key)
        assert verifier.verify(h, binary_signature), "Signature Verification Failed"

        return True

